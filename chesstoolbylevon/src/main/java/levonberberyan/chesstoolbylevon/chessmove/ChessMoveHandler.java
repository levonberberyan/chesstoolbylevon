package levonberberyan.chesstoolbylevon.chessmove;

import levonberberyan.chesstoolbylevon.chessboard.ChessBoardI;
import levonberberyan.chesstoolbylevon.chesspiece.ChessPieceSymbolicHandler;

public final class ChessMoveHandler implements ChessMoveHandlerInterface{
	/*
	 * Convert UCI move calculations to symbolic move
	 * Check and Parse the move from moveString generated by Stockfish
	 * @throws UCIMoveException
	 */
	public static String uciMoveCalculationsToSymbolicMove(String theUciMoveCalculations){
		// if stockfish, if ribka, if others
		
		// stockfish: bestmove (none)
		// fruit and rybka: bestmove a1a1
		// Robolitto: bestmove NULL
				
		String move = "";
		// check if valid and contains bestmove and ponder, for Stockfish UCI
		if(theUciMoveCalculations.contains("bestmove") && theUciMoveCalculations.contains("ponder")){
			move = theUciMoveCalculations.substring(theUciMoveCalculations.indexOf("bestmove ") + 9, theUciMoveCalculations.indexOf(" ponder"));
			//System.out.println("Bestmove: " + move);
		} else{
			//throw new UCIValidMoveException();
		}
				
		return move;
	}
	/*
	 * 
	 */
	public static ChessMove convertUCIMoveStringToChessMove(String theMoveInUciFormat, ChessBoardI theChessBoard){
		// *if stockfish, if ribka, if others
		// we just check for stockfish now
		
		ChessMove aChessMove = new ChessMove(theChessBoard);
		
		//*
		
		// Set chess move Coordinates
		aChessMove.setMoveCoordinates(ChessPieceSymbolicHandler.getXFromChessPieceSymbolic(theMoveInUciFormat.charAt(0)), 
				ChessPieceSymbolicHandler.getYFromChessPieceSymbolic(theMoveInUciFormat.charAt(1)), 
				ChessPieceSymbolicHandler.getXFromChessPieceSymbolic(theMoveInUciFormat.charAt(2)), 
				ChessPieceSymbolicHandler.getYFromChessPieceSymbolic(theMoveInUciFormat.charAt(3))); 
		
		// Check move type
		// 3 move types
		
		return aChessMove;
	}
}

